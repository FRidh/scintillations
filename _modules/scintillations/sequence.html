<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>scintillations.sequence &#8212; scintillations 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="scintillations 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">scintillations 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for scintillations.sequence</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Sequence</span>
<span class="sd">=========</span>

<span class="sd">Generate a sequence of scintillations.</span>

<span class="sd">Note that this implementation takes into account varying correlation time by updating</span>
<span class="sd">the impulse response, and not resampling.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">resample</span><span class="p">,</span> <span class="n">fftconvolve</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">scintillations.common</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scintillations.common</span> <span class="k">import</span> <span class="n">_fluctuations_with_variance</span>

<span class="c1">#from turbulence.vonkarman import covariance_wind as _covariance_vonkarman_wind</span>

<div class="viewcode-block" id="variance_gaussian"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.variance_gaussian">[docs]</a><span class="k">def</span> <span class="nf">variance_gaussian</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span> <span class="n">include_saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Variance of Gaussian fluctuations.</span>

<span class="sd">    :param distance: Distance.</span>
<span class="sd">    :param wavenumber: Wavenumber.</span>
<span class="sd">    :param scale: Correlation length</span>
<span class="sd">    :param mean_mu_squared: Mean mu squared.</span>

<span class="sd">    :param include_saturation: Whether to include log-amplitude saturation. In this case the variance is multiplied with the saturation factor, :func:`saturation_factor`.</span>
<span class="sd">    :returns: Variance</span>

<span class="sd">    .. math:: \\langle \\chi^2 \\rangle = \\langle S^2 \\rangle = \\frac{\\sqrt{\\pi}}{2} \\langle \\mu^2 \\rangle k^2 r L</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">mean_mu_squared</span> <span class="o">*</span> <span class="n">wavenumber</span><span class="o">*</span><span class="n">wavenumber</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">scale</span>
    <span class="k">if</span> <span class="n">include_saturation</span><span class="p">:</span>
        <span class="n">variance</span> <span class="o">*=</span> <span class="n">saturation_factor</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">variance</span></div>


<div class="viewcode-block" id="fluctuations_with_variance"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.fluctuations_with_variance">[docs]</a><span class="k">def</span> <span class="nf">fluctuations_with_variance</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">,</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">correlation_length</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span> <span class="n">include_saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate fluctuations with correct variance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_fluctuations_with_variance</span><span class="p">(</span><span class="n">variance_gaussian</span><span class="p">,</span> <span class="n">fluctuations</span><span class="p">,</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">correlation_length</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span> <span class="n">include_saturation</span><span class="p">)</span></div>


<div class="viewcode-block" id="covariance_gaussian"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.covariance_gaussian">[docs]</a><span class="k">def</span> <span class="nf">covariance_gaussian</span><span class="p">(</span><span class="n">spatial_separation</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the covariance of a Gaussian turbulence spectrum and spherical waves.</span>

<span class="sd">    See Daigle, 1987: equation 2 and 3.</span>

<span class="sd">    :param spatial_separation: Spatial separation.</span>
<span class="sd">    :param distance: Distance.</span>
<span class="sd">    :param wavenumber: Wavenumber.</span>
<span class="sd">    :param mean_mu_squared: Mean mu squared.</span>
<span class="sd">    :param scale: Outer length scale.</span>
<span class="sd">    :returns: Covariance</span>

<span class="sd">    .. math:: B{\\chi} (\\rho) = B{S}(\\rho) = \\frac{\\sqrt{\\pi}}{2} \\langle \\mu^2 \\rangle k^2 r L \\frac{\\Phi(\\rho/L) }{\\rho / L}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#covariance = 0.0</span>
    <span class="c1">#covariance += (spatial_separation!=0.0) * \</span>
                  <span class="c1">#np.nan_to_num( ( np.pi/4.0 * mean_mu_squared * (wavenumber*wavenumber) * \</span>
                  <span class="c1">#distance * scale * (erf(spatial_separation/scale) / \</span>
                  <span class="c1">#(spatial_separation/scale) ) ) )</span>

    <span class="c1">#covariance += (spatial_separation==0.0) * np.sqrt(np.pi)/2.0 * \</span>
                  <span class="c1">#mean_mu_squared * (wavenumber*wavenumber) * distance * scale</span>
    <span class="n">cor</span> <span class="o">=</span> <span class="n">correlation_spherical_wave</span><span class="p">(</span><span class="n">spatial_separation</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">variance_gaussian</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">)</span>
    <span class="n">covariance</span> <span class="o">=</span> <span class="n">cor</span> <span class="o">*</span> <span class="n">var</span>
    <span class="k">return</span> <span class="n">covariance</span></div>




<div class="viewcode-block" id="logamp_structure"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.logamp_structure">[docs]</a><span class="k">def</span> <span class="nf">logamp_structure</span><span class="p">(</span><span class="n">logamp_a</span><span class="p">,</span> <span class="n">logamp_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Structure function for log-amplitude fluctuations.</span>

<span class="sd">    See Daigle, equation 17.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">logamp_a</span><span class="o">-</span><span class="n">logamp_b</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="phase_structure"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.phase_structure">[docs]</a><span class="k">def</span> <span class="nf">phase_structure</span><span class="p">(</span><span class="n">phase_a</span><span class="p">,</span> <span class="n">phase_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Structure function for phase fluctuations.</span>

<span class="sd">    See Daigle, equation 18.</span>

<span class="sd">    The last term accounts for the fact that the mean phase difference of the signals may be nonzero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">phase_a</span><span class="o">-</span><span class="n">phase_b</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="n">phase_a</span><span class="o">-</span><span class="n">phase_b</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span><span class="o">**</span><span class="mf">2.0</span></div>


<div class="viewcode-block" id="logamp_variance"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.logamp_variance">[docs]</a><span class="k">def</span> <span class="nf">logamp_variance</span><span class="p">(</span><span class="n">logamp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logamp variance.</span>

<span class="sd">    See Daigle,  equation 19.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logamp</span><span class="p">)</span>
    <span class="n">logamp_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">amp</span><span class="o">/</span><span class="n">amp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">logamp_normalized</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="phase_variance"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.phase_variance">[docs]</a><span class="k">def</span> <span class="nf">phase_variance</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Phase variance.</span>

<span class="sd">    See Daigle, equation 20.</span>

<span class="sd">    The last term accounts for the fact that the mean phase difference of the signals may be nonzero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">phase</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">phase</span><span class="o">-</span><span class="n">phase</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span></div>


<div class="viewcode-block" id="generate_gaussian_fluctuations_standard"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.generate_gaussian_fluctuations_standard">[docs]</a><span class="k">def</span> <span class="nf">generate_gaussian_fluctuations_standard</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">correlation_time</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate Gaussian fluctuations with variance 1.</span>

<span class="sd">    :param nsamples: Length of the sequence in samples.</span>
<span class="sd">    :param ntaps: Length of the filter used to shape the PSD of the sequence.</span>
<span class="sd">    :param fs: Sample frequency.</span>
<span class="sd">    :param correlation_time: Correlation time. Single value or array with a value for each time instance.</span>
<span class="sd">    :param state: State of random number generator.</span>
<span class="sd">    :param window: Window used in filter design.</span>
<span class="sd">    :returns: Fluctuations.</span>

<span class="sd">    This function generates fluctuations that are Gaussian distributed and have a variance of 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Gaussian white noise</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">state</span> <span class="k">if</span> <span class="n">state</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
    <span class="n">nsamples_total</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">+</span> <span class="n">ntaps</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nsamples_total</span><span class="p">)</span>

    <span class="c1"># Time shifts for sampling temporal correlation function.</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">tau</span><span class="p">(</span><span class="n">ntaps</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

    <span class="c1"># Whether our correlation time is time-variant or not.</span>
    <span class="c1"># This is an optimization step.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">correlation_time</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">correlation_time</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Unique values</span>
            <span class="n">time_variant</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># Sequence with same value</span>
            <span class="n">correlation_time</span> <span class="o">=</span> <span class="n">correlation_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">time_variant</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>   <span class="c1"># Single value</span>
        <span class="n">time_variant</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">time_variant</span><span class="p">:</span>
        <span class="c1"># We need to convolve each sample with a unique impulse response.</span>
        <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">):</span>
            <span class="n">noise_block</span> <span class="o">=</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">ntaps</span><span class="p">]</span>
            <span class="n">correlation</span> <span class="o">=</span> <span class="n">correlation_spherical_wave</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">correlation_time</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="n">impulse_response_fluctuations</span><span class="p">(</span><span class="n">correlation</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
            <span class="n">fluctuations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fftconvolve</span><span class="p">(</span><span class="n">noise_block</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If time-invariant, we can perform a single convolution.</span>
        <span class="n">correlation</span> <span class="o">=</span> <span class="n">correlation_spherical_wave</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">correlation_time</span><span class="p">)</span>
        <span class="n">ir</span> <span class="o">=</span> <span class="n">impulse_response_fluctuations</span><span class="p">(</span><span class="n">correlation</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
        <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">fftconvolve</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>

    <span class="c1"># The filtering process adjusts the spectrum of the sequence and thereby the variance.</span>
    <span class="c1"># One might want to normalize with the standard deviation to take this into account.</span>
    <span class="c1"># However, the expected value of the sequence is still one, and therefore</span>
    <span class="c1"># normalization should not be done.</span>
    <span class="c1">#fluctuations /= fluctuations.std()</span>

    <span class="k">return</span> <span class="n">fluctuations</span></div>




<div class="viewcode-block" id="generate_fluctuations_logamp_and_phase"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.generate_fluctuations_logamp_and_phase">[docs]</a><span class="k">def</span> <span class="nf">generate_fluctuations_logamp_and_phase</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">,</span> <span class="n">correlation_length</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">soundspeed</span><span class="p">,</span>
                                           <span class="n">distance</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span> <span class="n">include_saturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate logamp and phase fluctuations.</span>

<span class="sd">    :returns: Logamp :math:`\chi(t)` and phase :math:`S(t)` fluctuations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">correlation_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">correlation_length</span><span class="p">)</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
    <span class="n">correlation_time</span> <span class="o">=</span> <span class="n">correlation_length</span> <span class="o">/</span> <span class="n">speed</span>
    <span class="n">mean_mu_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">mean_mu_squared</span><span class="p">)</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>

    <span class="n">wavenumber</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">frequency</span> <span class="o">/</span> <span class="n">soundspeed</span>
    <span class="c1"># Fluctuations with variance 1.</span>
    <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">generate_gaussian_fluctuations_standard</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">correlation_time</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

    <span class="c1"># Log-amplitude and phase fluctuations with correct variance.</span>
    <span class="n">logamp</span> <span class="o">=</span> <span class="n">fluctuations_with_variance</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">distance</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">correlation_length</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">mean_mu_squared</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">include_saturation</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span>  <span class="n">fluctuations_with_variance</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">distance</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">correlation_length</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">mean_mu_squared</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">logamp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_fluctuations_spectra_and_delay"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.generate_fluctuations_spectra_and_delay">[docs]</a><span class="k">def</span> <span class="nf">generate_fluctuations_spectra_and_delay</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">,</span> <span class="n">correlation_length</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">soundspeed</span><span class="p">,</span>
                                            <span class="n">distance</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span> <span class="n">include_saturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate fluctuations represented by a time-variant magnitude-only spectrum and a variable delay.</span>

<span class="sd">    :returns: Magnitude-only spectra as function of time, and delay as function of time</span>
<span class="sd">    .. seealso:: :func:`generate_complex_fluctuations`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">correlation_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">correlation_length</span><span class="p">)</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
    <span class="n">correlation_time</span> <span class="o">=</span> <span class="n">correlation_length</span> <span class="o">/</span> <span class="n">speed</span>
    <span class="n">mean_mu_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">mean_mu_squared</span><span class="p">)</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>

    <span class="n">wavenumber</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">frequency</span> <span class="o">/</span> <span class="n">soundspeed</span>
    <span class="c1"># Fluctuations with variance 1.</span>
    <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">generate_gaussian_fluctuations_standard</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">correlation_time</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

    <span class="c1"># Log-amplitude and phase fluctuations with correct variance.</span>
    <span class="n">logamp</span> <span class="o">=</span> <span class="n">fluctuations_with_variance</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">wavenumber</span><span class="p">,</span> <span class="n">distance</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">correlation_length</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">mean_mu_squared</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">include_saturation</span><span class="o">=</span><span class="n">include_saturation</span><span class="p">)</span>
    <span class="c1"># Phase fluctuations with correct variance for frequency=1</span>
    <span class="n">phase</span> <span class="o">=</span>  <span class="n">fluctuations_with_variance</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">soundspeed</span><span class="p">,</span> <span class="n">distance</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">correlation_length</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">mean_mu_squared</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Magnitude spectra</span>
    <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">amplitude_fluctuations</span><span class="p">(</span><span class="n">logamp</span><span class="p">))</span>

    <span class="c1"># Variable delay</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">delay_fluctuations</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">delay</span></div>


<div class="viewcode-block" id="apply_log_amplitude"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.apply_log_amplitude">[docs]</a><span class="k">def</span> <span class="nf">apply_log_amplitude</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">log_amplitude</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply log-amplitude fluctuations.</span>

<span class="sd">    :param signal: Pressure signal.</span>
<span class="sd">    :param log_amplitude: Log-amplitude fluctuations.</span>

<span class="sd">    .. math:: p_m = p \\exp{\\chi}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">signal</span> <span class="o">*</span> <span class="n">amplitude_fluctuations</span><span class="p">(</span><span class="n">log_amplitude</span><span class="p">)</span></div>


<div class="viewcode-block" id="apply_phase"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.apply_phase">[docs]</a><span class="k">def</span> <span class="nf">apply_phase</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply phase fluctuations.</span>

<span class="sd">    :param signal: Pressure signal.</span>
<span class="sd">    :param phase: Phase fluctuations.</span>
<span class="sd">    :param frequency: Frequency of tone.</span>
<span class="sd">    :param fs: Sample frequency.</span>

<span class="sd">    Phase fluctuations are applied through a resampling.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">delay_fluctuations</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">apply_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="apply_fluctuations"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.apply_fluctuations">[docs]</a><span class="k">def</span> <span class="nf">apply_fluctuations</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_amplitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply log-amplitude and/or phase fluctuations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">log_amplitude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">apply_log_amplitude</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">log_amplitude</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">apply_phase</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="apply_delay"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.apply_delay">[docs]</a><span class="k">def</span> <span class="nf">apply_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply propagation delay fluctuations.</span>

<span class="sd">    :param signal: Signal</span>
<span class="sd">    :param delay: Propagation delay fluctuations.</span>
<span class="sd">    :param fs: Sample frequency</span>
<span class="sd">    :returns: Frequency-modulated signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">k_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>          <span class="c1"># Create vector of indices</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">k_r</span> <span class="o">-</span> <span class="n">delay</span> <span class="o">*</span> <span class="n">fs</span>                      <span class="c1"># Create vector of warped indices</span>

    <span class="n">kf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>       <span class="c1"># Floor the warped indices. Convert to integers so we can use them as indices.</span>
    <span class="n">dk</span> <span class="o">=</span> <span class="n">kf</span> <span class="o">-</span> <span class="n">k</span>
    <span class="n">ko</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">kf</span><span class="p">)</span>
    <span class="n">kf</span><span class="p">[</span><span class="n">ko</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kf</span><span class="p">[</span><span class="n">ko</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">ko</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">dk</span><span class="p">)</span> <span class="o">*</span> <span class="n">signal</span><span class="p">[</span><span class="n">kf</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">dk</span><span class="p">)</span> <span class="o">*</span> <span class="n">signal</span><span class="p">[</span><span class="n">kf</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ko</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ko</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="c1">#+ 0.0 * (kf&lt;0)</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="modulate_tone"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.modulate_tone">[docs]</a><span class="k">def</span> <span class="nf">modulate_tone</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">fs_low</span><span class="p">,</span> <span class="n">correlation_length</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">soundspeed</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span>
                  <span class="n">ntaps_corr</span><span class="o">=</span><span class="mi">8192</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_amplitude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">include_phase</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modulate tone.</span>

<span class="sd">    :param signal: Signal to modulate.</span>
<span class="sd">    :param fs: Sample frequency of signal.</span>
<span class="sd">    :param fs_low: Sample frequency at which to generate the scintillations.</span>

<span class="sd">    .. note:: Time-dependent values like speed and correlation length are given per block.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">nsamples_low</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsamples</span> <span class="o">*</span> <span class="n">fs_low</span> <span class="o">/</span> <span class="n">fs</span><span class="p">))</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span>
    <span class="n">times_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nsamples_low</span><span class="p">)</span><span class="o">/</span><span class="n">fs_low</span>

    <span class="n">logamp</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">generate_fluctuations_logamp_and_phase</span><span class="p">(</span><span class="n">nsamples_low</span><span class="p">,</span> <span class="n">fs_low</span><span class="p">,</span> <span class="n">ntaps_corr</span><span class="p">,</span> <span class="n">correlation_length</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span>
                                                           <span class="n">soundspeed</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span> <span class="n">include_saturation</span><span class="o">=</span><span class="n">include_saturation</span><span class="p">,</span>
                                                           <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_amplitude</span><span class="p">:</span>
        <span class="n">logamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">times_low</span><span class="p">,</span> <span class="n">logamp</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">apply_log_amplitude</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">logamp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_phase</span><span class="p">:</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">delay_fluctuations</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">fs_low</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">times_low</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
        <span class="c1">#delay = delay * fs_low #/ frequency # FIXME: Apparently we need this factor. WHY???!</span>
        <span class="c1">#phase = np.interp(times, times_low, phase)</span>
        <span class="c1">#delay = delay_fluctuations(phase, fs_low)</span>

        <span class="n">signal</span> <span class="o">=</span> <span class="n">apply_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="modulate_broadband"><a class="viewcode-back" href="../../sequence.html#scintillations.sequence.modulate_broadband">[docs]</a><span class="k">def</span> <span class="nf">modulate_broadband</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nblock</span><span class="p">,</span> <span class="n">correlation_length</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">soundspeed</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span> <span class="n">ntaps_corr</span><span class="o">=</span><span class="mi">8192</span><span class="p">,</span>
             <span class="n">ntaps_spectra</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">include_amplitude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_phase</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modulate tone.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">/</span> <span class="n">nblock</span>
    <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">ntaps_spectra</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">spectrum</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">generate_fluctuations_spectra_and_delay</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">ntaps_corr</span><span class="p">,</span> <span class="n">correlation_length</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span>
                                                                 <span class="n">frequency</span><span class="p">,</span> <span class="n">soundspeed</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">mean_mu_squared</span><span class="p">,</span>
                                                                 <span class="n">include_saturation</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_amplitude</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">logamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">times_low</span><span class="p">,</span> <span class="n">logamp</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">apply_log_amplitude</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">logamp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_phase</span><span class="p">:</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">times_low</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">apply_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">signal</span></div>

<span class="c1">#def generate_gaussian_fluctuations(nsamples, ntaps, fs, correlation_length, speed, distance,</span>
                                   <span class="c1">#frequency, soundspeed, mean_mu_squared,</span>
                                   <span class="c1">#window=None, include_saturation=False,</span>
                                   <span class="c1">#state=None, factor=5.0):</span>
    <span class="c1">#&quot;&quot;&quot;Generate Gaussian fluctuations.</span>

    <span class="c1">#:param factor: To resolve spatial field you need a sufficient resolution.</span>

    <span class="c1">#This function generated log-amplitude and phase fluctuations with the correct variance for the specified frequency.</span>

    <span class="c1">#.. warning:: You likely do not want to use a window as it will dramatically alter the frequency response of the fluctuations.</span>
    <span class="c1">#.. seealso:: :func:`generate_gaussian_fluctuations_standard`</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#correlation_time = correlation_length / speed</span>
    <span class="c1">## Low resolution parameters</span>
    <span class="c1">#fs_low = factor / correlation_time</span>
    <span class="c1">#times = np.arange(nsamples)/fs</span>
    <span class="c1">###correlation = correlation_spherical_wave(tau(ntaps, fs_low), correlation_time)</span>
    <span class="c1">#upsample_factor = fs / fs_low</span>
    <span class="c1">#nsamples_low = np.ceil(nsamples / upsample_factor)</span>
    <span class="c1">#times_low = np.arange(nsamples_low) / fs_low</span>

    <span class="c1">## Modulation signal with variance 1</span>
    <span class="c1">#fluctuations = generate_gaussian_fluctuations_standard(nsamples_low, ntaps, fs_low, correlation_time, state, window)</span>

    <span class="c1">#wavenumber = 2.*np.pi*frequency / soundspeed</span>

    <span class="c1">## Log-amplitude fluctuations with correct variance.</span>
    <span class="c1">#logamp = logamp_fluctuations(fluctuations, wavenumber, distance, correlation_length, mean_mu_squared,</span>
                                 <span class="c1">#include_saturation=include_saturation)</span>

    <span class="c1">## Phase fluctuations with correct variance.</span>
    <span class="c1">#phase = phase_fluctuations(fluctuations, wavenumber, distance, correlation_length, mean_mu_squared)</span>

    <span class="c1">## Upsampled modulation signals</span>
    <span class="c1">#logamp = np.interp(times, times_low, logamp)</span>
    <span class="c1">#phase = np.interp(times, times_low, phase)</span>

    <span class="c1">#return logamp, phase</span>

<span class="c1">#from scipy.signal import resample</span>

<span class="c1">#def upsample(signal, factor, method=&#39;fourier&#39;):</span>
    <span class="c1">#&quot;&quot;&quot;Upsample signal with `factor`.</span>

    <span class="c1">#:param signal: Signal to be upsampled.</span>
    <span class="c1">#:param factor: Upsample factor.</span>
    <span class="c1">#:type factor: float</span>
    <span class="c1">#:returns: Upsampled signal.</span>

    <span class="c1">#.. seealso:: :func:`scipy.signal.resample`</span>

    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#nsamples_low = len(signal)</span>
    <span class="c1">#nsamples_high = nsamples_low * np.ceil(factor)</span>

    <span class="c1">#if method==&#39;fourier&#39;:</span>
        <span class="c1">#upsampled = resample(signal, nsamples_high)</span>
    <span class="c1">#elif method==&#39;linear&#39;:</span>
        <span class="c1">#times_low = np.linspace(0., 1., nsamples_low, endpoint=False)</span>
        <span class="c1">#times_high = np.linspace(0., 1., nsamples_high, endpoint=False)</span>
        <span class="c1">#upsampled = np.interp(times_high, times_low, signal)</span>
    <span class="c1">#else:</span>
        <span class="c1">#raise ValueError(&quot;Invalid method: {}&quot;.format(method))</span>

    <span class="c1">#return upsampled</span>


    <span class="c1">#if nsamples_upsampled:</span>
        <span class="c1">#times = np.arange(nsamples)</span>
        <span class="c1">#fs_upsampled = nsamples_upsampled / nsamples * fs</span>
        <span class="c1">#times_upsampled = np.arange(nsamples_upsampled) / fs_upsampled</span>
        <span class="c1">#logamp = np.interp(times_upsampled, times, logamp)</span>
        <span class="c1">#phase = np.interp(times_upsampled, times, phase)</span>



<span class="c1">#def modulate(signal, fs, correlation_length, speed, distance, soundspeed, mean_mu_squared, ntaps=8192,</span>
             <span class="c1">#nfreqs=100, window=None, include_saturation=False, state=None, factor=5.0,</span>
             <span class="c1">#include_amplitude=True, include_phase=True, fs_low=None):</span>
    <span class="c1">#&quot;&quot;&quot;Apply modulations to `signal`.</span>

    <span class="c1">#:param signal: Signal to apply modulations to.</span>
    <span class="c1">#:param fs: Sample frequency of signal.</span>
    <span class="c1">#:param correlation_length: Correlation length.</span>
    <span class="c1">#:param speed: Speed.</span>
    <span class="c1">#:param distance: Distance.</span>
    <span class="c1">#:param soundspeed: Speed of sound.</span>
    <span class="c1">#:param mean_mu_squared: Variance of refractive-index.</span>
    <span class="c1">#:param ntaps: Amount of taps to use to sample the correlation function.</span>
    <span class="c1">#:param nfreqs: Amount of frequencies to calculate the logamp variances for.</span>
    <span class="c1">#:param window: Window to apply when designing filter.</span>
    <span class="c1">#:param include_saturation: Include logamp saturation.</span>
    <span class="c1">#:param state: State of the PRNG.</span>
    <span class="c1">#:param factor: Oversampling factor.</span>
    <span class="c1">#:param include_amplitude: Whether to include logamp modulations.</span>
    <span class="c1">#:param include_phase: Whether to include phase modulations.</span>

    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#correlation_time = correlation_length / speed</span>
    <span class="c1">#if fs_low is None:</span>
        <span class="c1">#fs_low = np.max(5.0 / correlation_time)</span>

    <span class="c1">#times = np.arange(nsamples)/fs</span>

    <span class="c1">#upsample_factor = fs / fs_low</span>
    <span class="c1">#nsamples_low = np.ceil(nsamples / upsample_factor)</span>
    <span class="c1">#times_low = np.arange(nsamples_low) / fs_low</span>

    <span class="c1">#fluctuations = generate_complex_fluctuations</span>




<span class="k">def</span> <span class="nf">covariance</span><span class="p">(</span><span class="n">covariance_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">covariance_func</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">covariance_gaussian</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;spatial_separation&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">],</span>
                                   <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mean_mu_squared&#39;</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">covariance_func</span> <span class="o">==</span> <span class="s1">&#39;vonkarman_wind&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_covariance_vonkarman_wind</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;spatial_separation&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">],</span>
                                          <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;soundspeed&#39;</span><span class="p">],</span>
                                          <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;wind_speed_variance&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;steps&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;initial&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown covariance function </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">covariance_func</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">get_covariance</span><span class="p">(</span><span class="n">covariance</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">covariance</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">covariance_gaussian</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;spatial_separation&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">],</span>
                                       <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mean_mu_squared&#39;</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">covariance</span> <span class="o">==</span> <span class="s1">&#39;vonkarman_wind&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_covariance_vonkarman_wind</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;spatial_separation&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">],</span>
                                              <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;wavenumber&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;soundspeed&#39;</span><span class="p">],</span>
                                              <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;wind_speed_variance&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;steps&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;initial&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Covariance unavailable.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>

<span class="c1">#def covariance_gaussian(**kwargs):</span>
    <span class="c1">#return covariance(spatial_separation, distance, wavenumber, scale, mean_mu_squared)</span>

<span class="c1">#def covariance_vonkarman_wind(**kwargs):</span>
    <span class="c1">#return _covariance_vonkarman_wind(spatial_separation, distance, wavenumber, scale, soundspeed, wind_speed_variance, steps, initial)</span>

<span class="c1">#COVARIANCES = {</span>
        <span class="c1">#&#39;gaussian&#39; : covariance,</span>
        <span class="c1">#&#39;vonkarman_wind&#39; : covariance_vonkarman_wind,</span>
    <span class="c1">#}</span>


<span class="c1">###def generate_fluctuations(nsamples, ntaps, fs, speed, distance,</span>
                          <span class="c1">###frequency, soundspeed, scale, state=None,</span>
                          <span class="c1">###window=None, model=&#39;gaussian&#39;, **kwargs):</span>

    <span class="c1">###logging.debug(&quot;generate_fluctuations: covariance model {}&quot;.format(model))</span>

    <span class="c1">###try:</span>
        <span class="c1">###include_saturation = kwargs.pop(&#39;include_saturation&#39;)</span>
    <span class="c1">###except KeyError:</span>
        <span class="c1">###include_saturation = False</span>

    <span class="c1">#### Determine the covariance</span>
    <span class="c1">###spatial_separation = tau(ntaps, fs) * speed</span>
    <span class="c1">###wavenumber = 2.*np.pi*frequency / soundspeed</span>

    <span class="c1">###cov = covariance(model, spatial_separation=spatial_separation,</span>
                                 <span class="c1">###distance=distance,</span>
                                 <span class="c1">###wavenumber=wavenumber,</span>
                                 <span class="c1">###scale=scale, **kwargs)</span>

    <span class="c1">####cov0 = covariance_func(spatial_separation=0.0,</span>
                                 <span class="c1">####distance=distance,</span>
                                 <span class="c1">####wavenumber=wavenumber,</span>
                                 <span class="c1">####scale=scale, **kwargs)</span>
    <span class="c1">#### Create an impulse response using this covariance</span>
    <span class="c1">###ir = impulse_response_fluctuations(cov, window=window)</span>

    <span class="c1">#### We need random numbers.</span>
    <span class="c1">###state = state if state else np.random.RandomState()</span>

    <span class="c1">#### Calculate log-amplitude fluctuations</span>
    <span class="c1">####noise = state.randn(samples*2-1)</span>
    <span class="c1">####log_amplitude = fftconvolve(noise, ir, mode=&#39;valid&#39;)</span>
    <span class="c1">###noise = state.randn(nsamples)</span>
    <span class="c1">###log_amplitude = fftconvolve(noise, ir, mode=&#39;same&#39;)</span>
    <span class="c1">####log_amplitude -= cov[0]</span>


    <span class="c1">####log_amplitude -= (log_amplitude.mean() - logamp_variance(np.exp(log_amplitude)))</span>

    <span class="c1">#### Include log-amplitude saturation</span>
    <span class="c1">###if include_saturation:</span>
        <span class="c1">###if model == &#39;gaussian&#39;:</span>
            <span class="c1">###mean_mu_squared = kwargs[&#39;mean_mu_squared&#39;]</span>
            <span class="c1">###sat_distance = saturation_distance(mean_mu_squared, wavenumber, scale)</span>
            <span class="c1">###log_amplitude *=  (np.sqrt( 1.0 / (1.0 + distance/sat_distance) ) )</span>
        <span class="c1">###else:</span>
            <span class="c1">###raise ValueError(&quot;Cannot include saturation for given covariance function.&quot;)</span>

    <span class="c1">#### Calculate phase fluctuations</span>
    <span class="c1">####noise = state.randn(samples*2-1)</span>
    <span class="c1">####phase = fftconvolve(noise, ir, mode=&#39;valid&#39;)</span>
    <span class="c1">###noise = state.randn(nsamples)</span>
    <span class="c1">###phase = fftconvolve(noise, ir, mode=&#39;same&#39;)</span>

    <span class="c1">###return log_amplitude, phase</span>

<span class="c1">#def fluctuations_logamp(ir, noise):</span>
    <span class="c1">#log_amplitude = fftconvolve(noise, ir, mode=&#39;same&#39;)</span>
    <span class="c1">#return log_amplitude</span>

<span class="c1">#def fluctuations_phase(ir, noise):</span>
    <span class="c1">#phase = fftconvolve(noise, ir, mode=&#39;same&#39;)</span>
    <span class="c1">#return phase</span>





<span class="c1">#def logamp_variance(logamp, axis=-1):</span>
    <span class="c1">#amp = np.exp(logamp)</span>
    <span class="c1">#logamp_normalized = np.log(amp/amp.mean(axis=axis))</span>
    <span class="c1">#return logamp_normalized.var(axis=axis)</span>

<span class="c1">#def logamp_variance(amp):</span>
    <span class="c1">#&quot;&quot;&quot;Variance of log-amplitude fluctuations.</span>

    <span class="c1">#:param amp: Time-series of amplitude fluctuations, NOT log-amplitude.</span>

    <span class="c1">#See Daigle, 1983: equation 15, 16 and 19.</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#return (np.log(amp/(amp.mean(axis=-1)[...,None]))**2.0).mean(axis=-1)</span>
    <span class="c1">##return (( np.log(amp) - np.log(amp.mean(axis=-1) )[...,None])**2.0).mean(axis=-1)</span>


<span class="c1">#def generate_many_gaussian_fluctuations(samples, spatial_separation, distance, wavenumber,</span>
                                        <span class="c1">#mean_mu_squared, scale, window=np.hamming,</span>
                                        <span class="c1">#include_saturation=False, seed=None):</span>
    <span class="c1">#&quot;&quot;&quot;Generate time series of log-amplitude and phase fluctuations.</span>

    <span class="c1">#:param samples: Length of series of fluctuations.</span>
    <span class="c1">#:param spatial_separation: Spatial separation.</span>
    <span class="c1">#:param distance: Distance.</span>
    <span class="c1">#:param wavenumber: Wavenumber</span>
    <span class="c1">#:param mean_mu_squared: Mean mu squared.</span>
    <span class="c1">#:param scale: Outer length scale.</span>
    <span class="c1">#:param window: Window function.</span>
    <span class="c1">#:param include_saturation: Include saturation of log-amplitude.</span>
    <span class="c1">#:param seed: Seed.</span>
    <span class="c1">#:returns: Log-amplitude array and phase array.</span>

    <span class="c1">#This function performs better when many series need to be generated.</span>

    <span class="c1">#&quot;&quot;&quot;</span>

    <span class="c1">## Calculate correlation</span>
    <span class="c1">##B = (spatial_separation!=0.0) * np.nan_to_num( ( np.pi/4.0 * mean_mu_squared * (k*k)[:,None] * r[None,:] * L * (erf(spatial_separation/L) / (spatial_separation/L))[None,:] ) )</span>
    <span class="c1">##B = (spatial_separation==0.0)[None,:] * (np.sqrt(np.pi)/2.0 * mean_mu_squared * (k*k)* r * L )[:,None]</span>

    <span class="c1">#spatial_separation = np.atleast_1d(spatial_separation)</span>
    <span class="c1">#distance = np.atleast_1d(distance)</span>
    <span class="c1">#wavenumber = np.atleast_1d(wavenumber)</span>
    <span class="c1">#mean_mu_squared = np.atleast_1d(mean_mu_squared)</span>
    <span class="c1">#scale = np.atleast_1d(scale)</span>
    <span class="c1">#covariance = covariance_gaussian(spatial_separation[None,:], distance[:,None],</span>
                                          <span class="c1">#wavenumber[:,None], mean_mu_squared[:,None], scale[:,None])</span>

    <span class="c1">#if covariance.ndim==2:</span>
        <span class="c1">#N = covariance.shape[-2]</span>
    <span class="c1">#elif covariance.ndim==1:</span>
        <span class="c1">#N = 1</span>
    <span class="c1">#else:</span>
        <span class="c1">#raise ValueError(&quot;Unsupported amount of dimensions.&quot;)</span>

    <span class="c1">## Seed random numbers generator.</span>
    <span class="c1">#np.random.seed(seed)</span>
    <span class="c1">#n = samples * 2 - 1</span>

    <span class="c1">#ir = impulse_response_fluctuations(covariance, window=window)</span>

    <span class="c1">#noise = np.random.randn(N,n)</span>
    <span class="c1">#log_amplitude = fftconvolve1D(noise, ir, mode=&#39;valid&#39;) # Log-amplitude fluctuations</span>
    <span class="c1">#del noise</span>

    <span class="c1">#if include_saturation:</span>
        <span class="c1">#sat_distance = saturation_distance(mean_mu_squared, wavenumber, scale)</span>
        <span class="c1">#log_amplitude *=  (np.sqrt( 1.0 / (1.0 + distance/sat_distance) ) )[...,None]</span>
        <span class="c1">#del sat_distance</span>

    <span class="c1">#noise = np.random.randn(N,n)</span>
    <span class="c1">#phase = fftconvolve1D(noise, ir, mode=&#39;valid&#39;)           # Phase fluctuations</span>

    <span class="c1">#return log_amplitude, phase</span>




<span class="c1">#def gaussian_fluctuations_variances(samples, f0, fs, mean_mu_squared,</span>
                                    <span class="c1">#distance, scale,</span>
                                    <span class="c1">#spatial_separation, soundspeed,</span>
                                    <span class="c1">#include_saturation=True, state=None):</span>
    <span class="c1">#&quot;&quot;&quot;Calculate the variances of fluctuations in the time series of amplitude and phase fluctuations.</span>

    <span class="c1">#:param samples: Amount of samples to take.</span>
    <span class="c1">#:param f0: Frequency for which the fluctuations should be calculated.</span>
    <span class="c1">#:param fs: Sample frequency.</span>
    <span class="c1">#:param mean_mu_squared: Mean of refractive-index squared.</span>
    <span class="c1">#:param r: Distance.</span>
    <span class="c1">#:param L: Outer length scale.</span>
    <span class="c1">#:param rho: Spatial separation.</span>
    <span class="c1">#:param soundspeed: Speed of sound.</span>
    <span class="c1">#:param include_phase: Include phase fluctuations.</span>
    <span class="c1">#:param state: State of numpy random number generator.</span>

    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#spatial_separation *= np.ones(samples)</span>
    <span class="c1">#wavenumber = 2.0 * np.pi * f0 / soundspeed</span>
    <span class="c1">#a, p = generate_gaussian_fluctuations(samples, spatial_separation, distance,</span>
                                               <span class="c1">#wavenumber, mean_mu_squared, scale,</span>
                                               <span class="c1">#include_saturation=include_saturation,</span>
                                               <span class="c1">#state=state)</span>

    <span class="c1">#return logamp_variance(np.exp(a)), phase_variance(p)</span>


<span class="c1">#def fluctuations_variance(signals, fs, N=None):</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#Determine the variance in log-amplitude and phase by ensemble averaging.</span>

    <span class="c1">#:param signals: List of signals or samples.</span>
    <span class="c1">#:param fs: Sample frequency</span>

    <span class="c1">#The single-sided spectrum is calculated for each signal/sample.</span>

    <span class="c1">#The log-amplitude of the :math:`n`th sample is given by</span>

    <span class="c1">#.. math:: \\chi^2 = \\ln{\\frac{A_{n}}{A_{0}}}</span>

    <span class="c1">#where :math:`A_{n}` is the amplitude of sample :math:`n` and :math:`A_{0}` is the ensemble average</span>

    <span class="c1">#.. math:: A_{0} = \\frac{1}{N} \\sum_{n=1}^{N} \\chi_{n}^2</span>

    <span class="c1">#&quot;&quot;&quot;</span>

    <span class="c1">#s = np.array(signals) # Array of signals</span>

    <span class="c1">##print s</span>

    <span class="c1">#f, fr = ir2fr(s, fs, N) # Single sided spectrum</span>
    <span class="c1">#amp = np.abs(fr)</span>
    <span class="c1">#phase = np.angle(fr)</span>
    <span class="c1">#logamp_squared_variance = (np.log(amp/amp.mean(axis=0))**2.0).mean(axis=0)</span>
    <span class="c1">#phase_squared_variance = ((phase - phase.mean(axis=0))**2.0).mean(axis=0)</span>

    <span class="c1">#return f, logamp_squared_variance, phase_squared_variance</span>


<span class="c1">#def plot_variance(frequency, logamp, phase):</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#Plot variance.</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#fig = plt.figure()</span>
    <span class="c1">#ax = fig.add_subplot(111)</span>
    <span class="c1">#ax.scatter(frequency, logamp, label=r&quot;$\langle \chi^2 \rangle$&quot;, color=&#39;b&#39;)</span>
    <span class="c1">#ax.scatter(frequency, phase, label=r&quot;$\langle S^2 \rangle$&quot;, color=&#39;r&#39;)</span>
    <span class="c1">#ax.set_xlim(100.0, frequency.max())</span>
    <span class="c1">#ax.set_ylim(0.001, 10.0)</span>
    <span class="c1">#ax.set_xscale(&#39;log&#39;)</span>
    <span class="c1">#ax.set_yscale(&#39;log&#39;)</span>
    <span class="c1">#ax.legend()</span>
    <span class="c1">#ax.grid()</span>
    <span class="c1">#ax.set_xlabel(r&quot;$f$ in Hz&quot;)</span>
    <span class="c1">#ax.set_ylabel(r&quot;$\langle X \rangle$&quot;)</span>

    <span class="c1">#return fig</span>


<span class="c1">#def _spatial_separation(A, B, C):</span>
    <span class="c1">#&quot;&quot;&quot;Spatial separation.</span>

    <span class="c1">#:param A: Source position as function of time.</span>
    <span class="c1">#:param B: Reference position, e.g. source position at t-1</span>
    <span class="c1">#:param C: Receiver position.</span>

    <span class="c1">#Each row is a sample and each column a spatial dimension.</span>

    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#a = np.linalg.norm(B-C, axis=1)</span>
    <span class="c1">#b = np.linalg.norm(A-C, axis=1)</span>
    <span class="c1">#c = np.linalg.norm(A-B, axis=1)</span>

    <span class="c1">#gamma = np.arccos((a**2.0+b**2.0-c**2.0) / (2.0*a*b))</span>
    <span class="c1">#spatial_separation = 2.0 * b * np.sin(gamma/2.0)</span>
    <span class="c1">#L = b * np.cos(gamma/2.0)</span>

    <span class="c1">#return spatial_separation, L</span>


<span class="c1">#def transverse_speed(A, B, C, fs):</span>
    <span class="c1">#&quot;&quot;&quot;Transverse speed computed from three positions.</span>

    <span class="c1">#:param A: Source position as function of time.</span>
    <span class="c1">#:param B: Reference position, e.g. source position at t=0</span>
    <span class="c1">#:param C: Receiver position.</span>
    <span class="c1">#:param fs: Sample frequency</span>

    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="c1">#rho, _ = _spatial_separation(A, B, C)</span>

    <span class="c1">#step_distance = np.linalg.norm(A-B, axis=-1)</span>
    <span class="c1">#speed = step_distance * fs</span>
    <span class="c1">#transverse = rho / step_distance * speed</span>

    <span class="c1">#return transverse, rho, step_distance</span>



</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">scintillations 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 1970, Frederik Rietdijk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>