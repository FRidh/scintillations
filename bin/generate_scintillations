#! /usr/bin/env python
import os
import numpy as np
import pandas as pd
import argparse
import logging
logging.basicConfig(format="%(asctime)s: %(message)s", level=logging.INFO)

from scintillations.sequence import transverse_speed, generate_fluctuations_spectra_and_delay

# Extra parameters turbulence model
NTAPS = 128 # Amount of taps for the IR of the modulations. Amount of frequencies is typically NTAPS//2+1 (single-sided spectrum).
NTAPS_CORR = 8192   # Amount of taps for the IR of the correlation function.
WINDOW = None
INCLUDE_SATURATION = True   # Include log-amplitude saturation.
SAMPLE_FREQUENCY = 44100.

USE_TRANSVERSE_SPEED = True
"""Use transverse speed instead of magnitude of aircraft velocity."""

INPUT_DATA_COLUMNS = ['time', 'src_x', 'src_y', 'src_z', 'rec_x', 'rec_y', 'rec_z', 'soundspeed', 'outer_length', 'variance', 'randomseed']
"""Column names input file."""

# Parser
_parser = argparse.ArgumentParser(description='Generate scintillations.')
_parser.add_argument('input', help='Path to input data file. Filename should include extension.')
_parser.add_argument('output', help='Path to output data file. Filename should include extension.')


def compute_spectra_and_delay(nblocks, fb, correlation_length, speed, distance, mean_mu_squared, soundspeed, seed):
    """Compute complex spectra as function of time.

    :param nblocks: Amount of spectra to generate.
    :param fb: Block update rate.
    :param correlation_length: Correlation length.
    :param speed: Speed of the aircraft.
    :param distance: Source-receiver distance.
    :param mean_mu_squared: Variance of refractive-index fluctuations.
    #:returns: Tuple consisting of a 1-D array with frequencies `shape=(NTAPS//2-1)` and  a 2-D array with spectra as function of time `shape=(nblocks, NTAPS//2-1)`.

    """
    logging.info("Computing magnitude spectra and delays.")

    # Frequency bins of our spectra
    frequency = np.fft.rfftfreq(NTAPS, 1./SAMPLE_FREQUENCY)

    # State of PRNG
    state = np.random.RandomState(seed=seed)

    # Complex spectra as function of time
    spectra, delay = generate_fluctuations_spectra_and_delay(nblocks, fb, NTAPS_CORR, correlation_length, speed,
                                        frequency, soundspeed, distance, mean_mu_squared,
                                        include_saturation=INCLUDE_SATURATION, state=state, window=WINDOW)

    return frequency, spectra, delay

def main():

    # Parse arguments
    args = vars(_parser.parse_args())
    output_filename = args['output']
    input_filename = args['input']

    # Create output directory if it doesn't yet exist.
    directory = os.path.dirname(output_filename)
    #if directory:
        #logging.info("Creating output file directory {}".format(directory))
        #os.makedirs(directory)

    # Load input data
    logging.info("Loading input from {}".format(input_filename))
    input_data = pd.read_csv(input_filename)

    # Make sure the format of the input is as expected
    assert np.all(input_data.columns == INPUT_DATA_COLUMNS)

    time = input_data['time'].values
    seed = int(input_data['randomseed'].values[0]) # Select first value
    fb = 1./np.diff(time).mean()   # Sample frequency (block update rate)

    # Source-receiver distance
    distance = np.linalg.norm(input_data[['src_x', 'src_y', 'src_z']].values - input_data[['rec_x', 'rec_y', 'rec_z']].values, axis=-1)

    source = input_data[['src_x', 'src_y', 'src_z']].values
    velocity = np.diff(source, axis=0) * fb
    velocity = np.vstack((velocity, velocity[-1])) # diff gives one value less.

    # Speed
    if USE_TRANSVERSE_SPEED:
        # Speed of aircraft transverse to wave propagation direction
        logging.info("Using transverse speed.")
        receiver = input_data[['rec_x', 'rec_y', 'rec_z']].values
        #A = np.vstack((source[1:], source[-1]))
        #B = np.vstack((source[:-1], source[-1]))
        #C = input_data[['rec_x', 'rec_y', 'rec_z']].values
        #speed, _, _ = transverse_speed(A, B, C, fb)
        #speed = np.nan_to_num(speed)
        orientation = (source-receiver) / np.linalg.norm(source - receiver, axis=-1)[...,None]
        speed = np.array(list(map(transverse_speed, velocity, orientation)))
    else:
        # Speed of aircraft
        logging.info("Using magnitude of velocity.")
        speed = np.linalg.norm(velocity, axis=-1)

    # Other parameters
    nsamples = len(time)
    length_scale = input_data['outer_length'].values
    mean_mu_squared = input_data['variance'].values
    soundspeed = input_data['soundspeed'].values[0]

    # Need to properly convert
    correlation_length = length_scale

    # Generate fluctuations
    logging.info("Generating magnitude spectra and delays.")
    frequencies, spectra, delay = compute_spectra_and_delay(nsamples, fb, correlation_length, speed, distance, mean_mu_squared, soundspeed, seed)
    # Create output dataframe in case of spectra and delay
    delay = pd.DataFrame({'delay': delay}, index=time)
    output_data = pd.concat([delay, pd.DataFrame(spectra, columns=frequencies, index=time)], axis=-1)
    output_data.index.name = 'time'

    # Write output to file
    logging.info("Writing output to {}".format(output_filename))
    output_data.to_csv(output_filename)



if __name__ == '__main__':
    main()
